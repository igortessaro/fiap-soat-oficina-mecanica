name: ðŸš€ Complete Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
        - production
      deploy_infrastructure:
        description: 'Deploy Infrastructure (Terraform)'
        required: true
        default: true
        type: boolean
      deploy_applications:
        description: 'Deploy Applications (Kubernetes)'
        required: true
        default: true
        type: boolean
      db_password:
        description: 'Database password'
        required: true
        type: string
        default: 'workshop123'

env:
  AWS_REGION: us-east-1
  TF_VAR_db_password: ${{ inputs.db_password }}

jobs:
  terraform:
    name: ðŸ—ï¸ Deploy Infrastructure
    runs-on: ubuntu-latest
    if: inputs.deploy_infrastructure == true

    defaults:
      run:
        working-directory: terraform/environments/${{ inputs.environment }}

    outputs:
      cluster_id: ${{ steps.terraform_output.outputs.cluster_id }}
      rds_endpoint: ${{ steps.terraform_output.outputs.rds_endpoint }}
      vpc_id: ${{ steps.terraform_output.outputs.vpc_id }}

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ”§ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: âš¡ Terraform Init
      run: terraform init

    - name: ðŸ“‹ Terraform Plan
      run: terraform plan -var="db_password=${{ inputs.db_password }}" -out=tfplan

    - name: ðŸš€ Terraform Apply
      run: terraform apply -auto-approve tfplan

    - name: ðŸ“Š Terraform Output
      id: terraform_output
      run: |
        echo "cluster_id=$(terraform output -raw cluster_id)" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT
        echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT

  deploy-apps:
    name: ðŸš€ Deploy Applications
    runs-on: ubuntu-latest
    if: inputs.deploy_applications == true && (always() && (needs.terraform.result == 'success' || needs.terraform.result == 'skipped'))
    needs: [terraform]

    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ðŸ”§ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: âš™ï¸ Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: ðŸ”— Configure kubectl for EKS
      run: |
        # Use output from terraform job if available, otherwise use default cluster name
        CLUSTER_NAME="${{ needs.terraform.outputs.cluster_id || 'smart-mechanical-workshop-production' }}"
        echo "Configuring kubectl for cluster: $CLUSTER_NAME"
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
        kubectl cluster-info

    - name: ðŸ—„ï¸ Get RDS Endpoint
      id: rds_info
      run: |
        # Use output from terraform job if available, otherwise get from terraform output
        if [ -n "${{ needs.terraform.outputs.rds_endpoint }}" ]; then
          RDS_ENDPOINT="${{ needs.terraform.outputs.rds_endpoint }}"
        else
          echo "Getting RDS endpoint from terraform state..."
          cd terraform/environments/${{ inputs.environment }}
          RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
        fi

        # Extract hostname from RDS endpoint (remove port)
        RDS_HOST=$(echo "$RDS_ENDPOINT" | cut -d':' -f1)
        echo "rds_host=$RDS_HOST" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
        echo "âœ… RDS Endpoint: $RDS_ENDPOINT"

    - name: ðŸ”§ Update ConfigMap with RDS Endpoint
      working-directory: k8s/overlays/aws-${{ inputs.environment }}
      run: |
        RDS_HOST="${{ steps.rds_info.outputs.rds_host }}"
        echo "Updating ConfigMap with RDS endpoint: $RDS_HOST"

        # Update configmap-aws.yaml with real RDS endpoint
        sed -i "s|RDS_ENDPOINT_PLACEHOLDER|$RDS_HOST|g" configmap-aws.yaml
        sed -i "s|smart-mechanical-workshop-production-db\..*\.us-east-1\.rds\.amazonaws\.com|$RDS_HOST|g" configmap-aws.yaml

        echo "âœ… ConfigMap updated with RDS endpoint"

    - name: ðŸ“¦ Deploy Namespace and Secrets
      run: |
        kubectl apply -f k8s/base/namespace.yaml
        kubectl apply -f k8s/base/secrets.yaml

    - name: ðŸ—„ï¸ Deploy ConfigMap
      working-directory: k8s/overlays/aws-${{ inputs.environment }}
      run: kubectl apply -f configmap-aws.yaml -n smart-mechanical-workshop

    - name: ðŸš€ Deploy Applications
      working-directory: k8s/overlays/aws-${{ inputs.environment }}
      run: |
        echo "Deploying MailHog..."
        kubectl apply -f ../../base/mailhog-deployment.yaml -n smart-mechanical-workshop

        echo "Deploying API..."
        kubectl apply -f ../../base/api-deployment.yaml -n smart-mechanical-workshop

        echo "Deploying Services..."
        kubectl apply -f services-loadbalancer.yaml -n smart-mechanical-workshop

    - name: ðŸ—ƒï¸ Initialize Database
      working-directory: k8s/overlays/aws-${{ inputs.environment }}
      run: |
        echo "Applying database initialization scripts..."
        kubectl apply -f db-init-simple.yaml -n smart-mechanical-workshop

        # Delete any existing job first
        kubectl delete job db-init-simple -n smart-mechanical-workshop --ignore-not-found=true

        # Apply the job
        kubectl apply -f db-init-job-simple.yaml -n smart-mechanical-workshop

    - name: â³ Wait for Deployments
      run: |
        echo "Waiting for API deployment..."
        kubectl rollout status deployment/api-deployment -n smart-mechanical-workshop --timeout=600s

        echo "Waiting for MailHog deployment..."
        kubectl rollout status deployment/mailhog-deployment -n smart-mechanical-workshop --timeout=300s

    - name: ðŸ” Get LoadBalancer URLs
      id: urls
      run: |
        echo "Waiting for LoadBalancer services to be ready..."
        sleep 120

        API_URL=$(kubectl get service api-service -n smart-mechanical-workshop -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        MAILHOG_URL=$(kubectl get service mailhog-service -n smart-mechanical-workshop -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "mailhog_url=$MAILHOG_URL" >> $GITHUB_OUTPUT

    - name: ðŸ§ª Test API Health
      run: |
        API_URL="${{ steps.urls.outputs.api_url }}"
        if [ -n "$API_URL" ]; then
          echo "Testing API health at: http://$API_URL/health"
          for i in {1..15}; do
            if curl -f -s "http://$API_URL/health" | grep -q "Healthy"; then
              echo "âœ… API is healthy!"
              break
            else
              echo "â³ API not ready yet, attempt $i/15..."
              sleep 30
            fi
          done
        else
          echo "âš ï¸ API URL not available yet"
        fi

    - name: ðŸ“Š Deployment Summary
      run: |
        echo "## ðŸŽ‰ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "${{ inputs.deploy_infrastructure }}" == "true" ]; then
          echo "### ðŸ—ï¸ Infrastructure Deployed:" >> $GITHUB_STEP_SUMMARY
          echo "- **EKS Cluster:** \`${{ needs.terraform.outputs.cluster_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **RDS Endpoint:** \`${{ needs.terraform.outputs.rds_endpoint }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **VPC:** \`${{ needs.terraform.outputs.vpc_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "${{ inputs.deploy_applications }}" == "true" ]; then
          echo "### ðŸš€ Applications Deployed:" >> $GITHUB_STEP_SUMMARY

          kubectl get pods -n smart-mechanical-workshop -o wide >> pods_status.txt
          echo "#### ðŸ“¦ Pods Status:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          cat pods_status.txt >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ steps.urls.outputs.api_url }}" ]; then
            echo "### ðŸ”— Access URLs:" >> $GITHUB_STEP_SUMMARY
            echo "- **API:** http://${{ steps.urls.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
            echo "- **API Health:** http://${{ steps.urls.outputs.api_url }}/health" >> $GITHUB_STEP_SUMMARY
            echo "- **MailHog:** http://${{ steps.urls.outputs.mailhog_url }}:8025" >> $GITHUB_STEP_SUMMARY
          fi
        fi
